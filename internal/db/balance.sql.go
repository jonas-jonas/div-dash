// Code generated by sqlc. DO NOT EDIT.
// source: balance.sql

package db

import (
	"context"
)

const getBalance = `-- name: GetBalance :many
SELECT 
    symbol,
    CAST(SUM(CASE 
            WHEN t.side = 'buy' THEN t.amount
            ELSE t.amount * -1
        END
    ) AS DOUBLE PRECISION) AS total
FROM "transaction" as t
WHERE t.user_id = $1
GROUP BY symbol
`

type GetBalanceRow struct {
	Symbol string  `json:"symbol"`
	Total  float64 `json:"total"`
}

func (q *Queries) GetBalance(ctx context.Context, userID string) ([]GetBalanceRow, error) {
	rows, err := q.query(ctx, q.getBalanceStmt, getBalance, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBalanceRow
	for rows.Next() {
		var i GetBalanceRow
		if err := rows.Scan(&i.Symbol, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCostBasis = `-- name: GetCostBasis :one
WITH A AS (
    SELECT 
        row_number() OVER (ORDER BY date) n,
        side,
        amount,
        price,
        SUM(
            CASE 
                WHEN side = 'buy' THEN amount
                ELSE amount * -1
            END
        ) OVER (ORDER BY date, id) as current_amount
    FROM "transaction"
    WHERE symbol = $1 AND user_id = $2
),
R AS (
    SELECT 
        n,
        current_amount,
        price as running_total
    FROM A 
    WHERE n = 1
    UNION ALL 
    SELECT 
        A.n, 
        A.current_amount,
        CASE 
            WHEN A.side = 'buy' THEN (R.current_amount * R.running_total + A.amount*A.price)/(R.current_amount+A.amount)
            ELSE running_total
        END as running_total
    FROM R
        JOIN A 
            ON A.n = R.n+1
)

SELECT cast(R.running_total as BIGINT) as cost_basis FROM R
ORDER BY n DESC
LIMIT 1
`

type GetCostBasisParams struct {
	Symbol string `json:"symbol"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetCostBasis(ctx context.Context, arg GetCostBasisParams) (int64, error) {
	row := q.queryRow(ctx, q.getCostBasisStmt, getCostBasis, arg.Symbol, arg.UserID)
	var cost_basis int64
	err := row.Scan(&cost_basis)
	return cost_basis, err
}
